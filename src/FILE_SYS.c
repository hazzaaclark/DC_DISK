/* COPYRIGHT (C) HARRY CLARK 2023 */

/* SEGA DREAMCAST ROM DISK TOOLKIT */

/* THIS FILE PERTAINS TOWARDS THE FUNCTIONALITY BY WHICH */
/* THE SEGA DREAMCAST'S FILE SYSTEM WORKS IN ACCORDANCE WITH */
/* THE HARDWARE TO CREATE EFI FILE SYSTEMS */

/* NESTED INCLUDES */

#include "FILE_SYS.h"

#ifdef USE_FILE_SYS

/* ASSUMING THE CURRENT DIRECTORY HAS BEEN INITIALISED */
/* WE BEGIN TO ESTABLISH THE NODE BASED SYSTEM BY WHICH */
/* FILES ARE TRANSFERRED TO AND FROM ACROSS ALL AREAS OF */
/* THE STACK */

/* WE USE THREADDING REFERNCING TO BE ABLE TO READ */
/* AND WRITE CORRESPONDING CONTENTS TO FILES */

STATIC
FS_DIRECTORY* ROOT_DIRECTORY(UNK* HANDLE)
{
    #undef USE_THREADDING

    struct FS_DIRECTORY* ROOT;
    struct MMU_HANDLER* MMU;
    struct MMU_NODE* MMU_NODES;

    CONTENT* CONTENT = (int*)malloc(HANDLE);

    /* THIS APPLIES FOR EVERY SUBSEQUENT LINE */
    /* AND OR IF THE EVALUATION OF THE CONTENT */
    /* IN SAID LINE EQUATES TO 0 */

    for (UNK i = 0; i < CONTENT; i++)
    {
        if(MMU_NODES == 0 || '/')
            strcpy(ROOT->NAME, sizeof(&MMU + 1));   

        else
            strcpy(ROOT->NAME, sizeof(&MMU));
    }

    /* FOR EVERYTHING STRING COPY OF EVERY SUBSEQUENT LINE */
    /* INCREMENT THE HANDLER POINTER BY 1 */

    HANDLE = (void*)malloc(sizeof(HANDLE + 1));

    return &ROOT;
}

/* RETURN THE RELATIVE SIZE OF THE FILE SYSTEM ROOT HEADER */
/* THIS WILL BECOME IMPORTANT WHEN READING THE CONTENTS */

STATIC
FS_HANDLER* FILE_SYS_ROOT(void)
{
    struct FS_HANDLER* FS_ROOT;
    return malloc(sizeof(FS_ROOT));
}

/* THIS METHOD HANNDLES A RAW FILE SYSTEM HANDLER */
/* SUCH THAT IS ABLE TO DETERMINE A PLAUSIBLE FILE */
/* PATH BASED ON FILE DESCRIPTORS */

STATIC
FS_HANDLER* FILE_SYS_OPEN(const char* FUNCTION, unsigned int* MODE)
{
    struct FS_HANDLER* FILE_SYS_BASE;
    char* REFERENCE[FILE_SYS_MAX];

    /* ASSUME THAT THE FILE SYSTEM IS BEING */
    /* OPERATED FROM THE ROOT */

    if(!strncmp(FUNCTION, "/", 0))
    {
        /* IF THE BUFFER IS WITHIN THE SPECIFIED PARAMETERS */

        if(MODE > sizeof(FILE_SYS_DIR))
            return FILE_SYS_ROOT();
        
        else
            return NULL;
        
    }
}

/* ASSIGN A FILE DESCRIPTOR SUCH THAT THE FILE SYSTEM WILL BE ABLE */
/* TO EFFECTIVELY POINT TOWARDS THE DESIGNATED MEMORY OF THE HANDLER */

STATIC
S32* FILE_SYS_DESCRIPTOR(struct FS_HANDLER** HANDLER)
{
    UNK INDEX;

    /* THE FOLLOWING LOOP WILL CHECK FOR THE DESIGNATED SIZE */
    /* OF THE FILE SYSTEM STACK */

    /* FROM THERE, THE INDEXXING WILL LOOK TO PROVIDE A STATIC TYPE */
    /* TO ACT AS THE DESCRIPTOR */

    /* DESCRIPTORS GOVERN THE BASIS OF WHICH A FILE IS OPENED */
    /* PARSED AND PROCESSED TO MODIFY CONTENTS */

    for (INDEX = 0; INDEX < sizeof(FILE_SYS_SIZE); INDEX++)
    {
        HANDLER[INDEX] = (int*)malloc(sizeof(HANDLER));

        /* IF NOTHING EXISTS */

        if(HANDLER == NULL)
            errno = EMFILE;
            return -1;
    }

    return INDEX;
}

/* NOW THE FILE SYSTEM CAN OPEN THE CORRESPONDING FILE */
/* GIVEN A PATH, IT WILL OPEN THE FILE BASED ON WHERE THE */
/* FILE IS BEING OPENED FROM */

STATIC
UNK* FILE_SYS_HANDLER_OPEN(const char* FUNCTION, unsigned int* MODE)
{
    struct FS_HANDLER* FILE_SYS_HANDLE;

    /* OPEN THE FILE BASED ON THE FUNCTION TYPE AS WELL AS */
    /* THE READ MODE */

    /* THE MODE GOVERNS THE LEVEL OF ACCESS THE FS HAS */

    FILE_SYS_HANDLE = FILE_SYS_OPEN(FUNCTION, MODE);

    if(!FILE_SYS_HANDLE)
    {
        return -1;
    }

    return 0;
}

#endif
